### Memory Management
- Memory in a computer system is divided into primary and secondary memory.
- Primary memory holds information (data and programs) while the CPU is using it.
- Secondary memory refers to storage devices that stores information when the CPU is not using it.
- Memory manager is responsible for allocating and deallocating  primary memory.
- It ensures that the memory is not abused and is used efficiently.

### Memory Manager
- Requirements
	- Minimize executable memory access time
	- Maximize executable memory size
	- Executable memory must be cost-effective
- Today's memory manager
	- Allocates primary memory to processes 
	- Maps process address space to primary memory
	- Minimizes access time using cost-effective memory configuration
	- May use static or dynamic techniques

### Storage Hierarchies
- Memory in a computer system can be divided into a hierarchy based on their characteristics.
- It also reflects how we work in the real world.
- At the top of the hierarchy is faster, but more expensive memory. e.g. Registers.
- At the bottom is slower, but cheaper memory. e.g. Hard disk, tape drives.

### Managing Address Space
 - When a program is converted (compiled) into executable form, there is no need to attach addresses to every single instruction in the program.

**Why?**
- Program instructions need to be stored in a particular order in order for the CPU to execute in the correct way.
- Programs involve many 'jumps' to different parts of the program. In order to do this, there has to be a concept of addresses for every part of the program.
- Imagine someone asking you to go to a person's house. Unless the address is given to you, there is no way you can get to that house.
- This process is called Address Binding.

### Creating an Executable Program
- Compile time: Translate elements
- Link time: Combine elements
- Load time:
	- Allocate primary memory
	- Adjust addresses in address space
	- Copy address space from secondary to primary memory

### Address Binding
- There are three ways to ensure that when a program is loaded up into memory, each instruction has an address:
	- During compile time
	- During load time 
	- During run time

**Compile time binding**
- Addresses are attached to each instruction when program is compiled.
- Program is loaded into same location in memory whenever it is executed.
- Simple, and good for single-programmed systems. E.g. MS-DOS.
- Cannot be relocated into different locations in memory.

**Load time binding**
- During compilation, the program is attached with re-locatable addresses. E.g. start at 0x0000.
- When program is loaded into memory, the location of the first instruction is loaded into a special register.
- To access the program, take re-locatable address of instruction + value of special register.
- Once loaded into memory, the program cannot be relocated into another portion of the memory.

**Run time binding**
- Address binding is delayed until run-time.
- Similar in concept to load time binding. i.e. using a relocatable register.
- Address of instruction is calculated only when the instruction is required.
- Very flexible as program can be relocated into any portion of memory at any time.
- Used by modern OS for multi-programming.

### Logical vs Physical Address Space
- The concept of a logical address space that is bound to a separate physical address space is central to proper memory management.
	- Logical address is generated by the CPU; it is also referred to as a virtual address.
	- Physical address is the address seen by the memory unit.
- Logical and physical addresses are the same in compile-time and load-time address-binding schemes.
- Logical and physical addresses differ in run-time address-binding scheme.
- The set of all logical address is referred to as a logical address spaces and the set of all the corresponding physical addresses is referred to as physical address space.

### Memory Allocation
- With multi-programming, the computer system need to allocate memory to many programs with differing sizes.
- When a new program is loaded or when a program terminates, the computer system must be able to allocate memory or reclaim the memory for re-use.
- Several strategies exist:
	- Fixed partition
		- Primary memory is divided into a fixed number of fixed-size blocks/partiions
		- Partitions are typically not of equal size
		- Prone to internal fragmentation
	- Variable partition
		- Memory is allocated to processes on a need-to and available basis
		- Use dynamically determine, variable-sized blocks
		- Prone to external fragmentation.
		- Requires run-time address binding to resolve fragmentation problems.

### Fragmentation
- The perp